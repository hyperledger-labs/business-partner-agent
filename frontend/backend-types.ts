/*
 * Copyright (c) 2020-2022 - for information on the respective copyright owner
 * see the NOTICE file and/or the repository at
 * https://github.com/hyperledger-labs/business-partner-agent
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/.well-known/did.json": {
    get: operations["getDid"];
  };
  "/api/activities": {
    /** List Items, if no filters return all */
    get: operations["listActivities"];
  };
  "/api/admin/config": {
    /** Get runtime configuration */
    get: operations["getRuntimeConfig"];
  };
  "/api/admin/endpoints/register": {
    /**
     * Trigger the backend to write configured endpoints to the ledger. TAA digest
     *  has to be passed to explicitly confirm prior TTA acceptance by the user for
     *  this ledger interaction / session.
     */
    post: operations["registerEndpoints"];
  };
  "/api/admin/endpoints/registrationRequired": {
    get: operations["isEndpointsWriteRequired"];
  };
  "/api/admin/schema": {
    /** List configured schemas */
    get: operations["listSchemas"];
    /** Import an existing indy or json-ld schema as schema configuration */
    post: operations["addSchema"];
  };
  "/api/admin/schema/{id}": {
    /** Get a configured schema by id */
    get: operations["getSchema"];
    /** Update a schema configuration */
    put: operations["updateSchema"];
    /**
     * Removes a schema configuration. Doing so means the BPA will not process
     *  requests containing this schema id anymore.
     */
    delete: operations["removeSchema"];
  };
  "/api/admin/schema/{id}/trustedIssuer": {
    /** Add a trusted issuer to a schema */
    post: operations["addTrustedIssuer"];
  };
  "/api/admin/schema/{id}/trustedIssuer/{trustedIssuerId}": {
    /** Update a trusted issuer */
    put: operations["updateTrustedIssuer"];
    /** Delete a trusted issuer */
    delete: operations["deleteTrustedIssuer"];
  };
  "/api/admin/taa/get": {
    /** Get TAA record (digest, text, version) */
    get: operations["getTAARecord"];
  };
  "/api/admin/tag": {
    /** List configured tags */
    get: operations["listTags"];
    /** Add a tag */
    post: operations["addTag"];
  };
  "/api/admin/tag/{id}": {
    /** Get a configured tag */
    get: operations["getTag"];
    /** Update a tag */
    put: operations["updateTag"];
    /** Removes a tag. */
    delete: operations["removeTag"];
  };
  "/api/invitations": {
    /** Create a connection-invitation */
    post: operations["requestConnectionInvitation"];
  };
  "/api/invitations/accept": {
    /** Receive / accept invitation */
    post: operations["acceptInvitation"];
  };
  "/api/invitations/check": {
    /** Check invitation (receive) */
    post: operations["checkInvitation"];
  };
  "/api/issuer/creddef": {
    /** List credential definitions, items that I can issue */
    get: operations["listCredDefs"];
    /** Create a new indy credential definition, and send it to the ledger */
    post: operations["createCredDef"];
  };
  "/api/issuer/creddef/{id}": {
    /** Delete a indy credential definition (will not delete it from the ledger) */
    delete: operations["deleteCredDef"];
  };
  "/api/issuer/exchanges": {
    /** List issued or received credentials */
    get: operations["listCredentialExchanges"];
  };
  "/api/issuer/exchanges/{id}": {
    /** Get credential exchange */
    get: operations["getCredentialExchange"];
  };
  "/api/issuer/exchanges/{id}/decline-proposal": {
    /**
     * Manual credential exchange: Issuer declines credential proposal received from
     *  the holder
     */
    put: operations["declineCredentialExchange"];
  };
  "/api/issuer/exchanges/{id}/re-issue": {
    /**
     * Send holder a new credential offer based on an existing (revoked) exchange
     *  record
     */
    post: operations["reIssueCredential"];
  };
  "/api/issuer/exchanges/{id}/revoke": {
    /** Revoke an issued credential */
    put: operations["revokeCredential"];
  };
  "/api/issuer/exchanges/{id}/send-offer": {
    /**
     * Manual credential exchange step two: Issuer sends credential counter offer to
     *  holder (in reference to a proposal)
     */
    put: operations["sendCredentialOffer"];
  };
  "/api/issuer/issue-credential/oob-attachment": {
    /**
     * Issue OOB credential step 1 - prepares credential offer and returns URL for
     *  use within the barcode
     */
    post: operations["issueCredentialConnectionLess"];
  };
  "/api/issuer/issue-credential/send": {
    /** Auto credential exchange: Issuer sends credential to holder */
    post: operations["issueCredential"];
  };
  "/api/issuer/schema": {
    /** Create a new schema on the indy ledger and import it */
    post: operations["createSchema"];
  };
  "/api/messaging/send-invitation": {
    /** Manual trigger to send an invitation url by email */
    post: operations["sendInvitationMail"];
  };
  "/api/messaging/template": {
    /** List message templates */
    get: operations["listMessageTemplates"];
    /** Add new message template */
    post: operations["addMessageTemplate"];
  };
  "/api/messaging/template/{id}": {
    /** Update message template */
    put: operations["updateMessageTemplate"];
    /** Delete message template */
    delete: operations["deleteMessageTemplate"];
  };
  "/api/messaging/trigger": {
    /** List message trigger configuration */
    get: operations["listMessageTrigger"];
    /** ASdd new message trigger configuration */
    post: operations["addMessageTrigger"];
  };
  "/api/messaging/trigger/{id}": {
    /** Update message trigger configuration */
    put: operations["updateMessageTrigger"];
    /** Delete message trigger configuration */
    delete: operations["deleteMessageTrigger"];
  };
  "/api/messaging/user-info": {
    /** List user info */
    get: operations["listUserInfo"];
    /** Add new user info configuration */
    post: operations["addUserInfo"];
  };
  "/api/messaging/user-info/{id}": {
    /** Update user info configuration */
    put: operations["updateUserInfo"];
    /** Delete user info configuration */
    delete: operations["deleteUserInfo"];
  };
  "/api/partners": {
    /** Get known partners */
    get: operations["getPartners"];
    /** Add a new partner */
    post: operations["addPartner"];
  };
  "/api/partners/lookup/{did}": {
    /** Lookup/Preview a partners public profile before adding */
    get: operations["lookupPartner"];
  };
  "/api/partners/{id}": {
    /** Get partner by id */
    get: operations["getPartnerById"];
    /** Update partner */
    put: operations["updatePartner"];
    /** Remove partner */
    delete: operations["removePartner"];
  };
  "/api/partners/{id}/accept": {
    /** Manual connection flow. Accept partner connection request */
    put: operations["acceptPartnerRequest"];
  };
  "/api/partners/{id}/credential-request": {
    /** Request credential from partner */
    post: operations["requestCredential"];
  };
  "/api/partners/{id}/did": {
    /** Update partner's did */
    put: operations["updatePartnerDid"];
  };
  "/api/partners/{id}/messages": {
    /** Get chat messages for partner */
    get: operations["getMessagesForPartner"];
    /** Send chat message to partner */
    post: operations["sendMessage"];
  };
  "/api/partners/{id}/proof-exchanges": {
    /** List proof exchange records */
    get: operations["getPartnerProofs"];
  };
  "/api/partners/{id}/proof-request": {
    /**
     * Request proof from partner
     *
     *               ProofExchangeController#requestProof
     */
    post: operations["requestProof"];
  };
  "/api/partners/{id}/proof-request/{templateId}": {
    /** Request proof from partner by proof template */
    put: operations["invokeProofRequestByTemplate"];
  };
  "/api/partners/{id}/proof-send": {
    /**
     * Send proof to partner
     *
     *               ProofExchangeController#sendProof
     */
    post: operations["sendProof"];
  };
  "/api/partners/{id}/refresh": {
    /** Reload/Re- lookup a partners public profile */
    get: operations["refreshPartner"];
  };
  "/api/proof-exchanges/proof-request": {
    /** Request proof from partner */
    post: operations["requestProof_1"];
  };
  "/api/proof-exchanges/proof-send": {
    /** Send proof to partner */
    post: operations["sendProof_1"];
  };
  "/api/proof-exchanges/{id}": {
    /** Get proof exchange by id */
    get: operations["getProofExchangeById"];
    /** Aries: Deletes a proof exchange by id */
    delete: operations["deleteProofExchangeById"];
  };
  "/api/proof-exchanges/{id}/decline": {
    /** Manual proof exchange flow. Reject ProofRequest received from a partner */
    post: operations["declinePresentProofRequest"];
  };
  "/api/proof-exchanges/{id}/matching-credentials": {
    /**
     * Manual proof exchange flow. Get matching wallet credentials before sending or
     *  declining the proof request.
     */
    get: operations["getMatchingCredentials"];
  };
  "/api/proof-exchanges/{id}/matching-credentials-ld": {
    get: operations["getMatchingLDCredentials"];
  };
  "/api/proof-exchanges/{id}/prove": {
    /** Manual proof exchange flow. Answer ProofRequest with matching attributes */
    post: operations["responseToProofRequest"];
  };
  "/api/proof-templates": {
    /** List configured templates */
    get: operations["listProofTemplates"];
    /** Add a new proof template */
    post: operations["addProofTemplate"];
  };
  "/api/proof-templates/known-condition-operators": {
    /** List configured proof condition operators */
    get: operations["listKnownConditionOperators"];
  };
  "/api/proof-templates/{id}": {
    /** Get template by id */
    get: operations["getProofTemplateForId"];
    /** Delete proof template by id */
    delete: operations["removeProofTemplate"];
  };
  "/api/status": {
    /** Get simple BPA information and usage statistics */
    get: operations["getStats"];
  };
  "/api/wallet/credential": {
    /** Aries: List wallet credentials */
    get: operations["getCredentials"];
  };
  "/api/wallet/credential/{id}": {
    /** Aries: Get wallet credential by id */
    get: operations["getCredentialById"];
    /** Aries: Set/update a credentials label */
    put: operations["updateCredential"];
    /** Aries: Delete a wallet credential by id */
    delete: operations["deleteCredential"];
  };
  "/api/wallet/credential/{id}/accept-offer": {
    /**
     * Manual credential exchange step four: Holder accepts credential offer from
     *  issuer
     */
    put: operations["acceptCredentialOffer"];
  };
  "/api/wallet/credential/{id}/decline-offer": {
    /** Manual credential exchange: Holder declines credential offer from issuer */
    put: operations["declineCredentialOffer"];
  };
  "/api/wallet/credential/{id}/toggle-visibility": {
    /** Toggles the credential's visibility in the public profile */
    put: operations["toggleCredentialVisibility"];
  };
  "/api/wallet/document": {
    /** List wallet documents */
    get: operations["getDocuments"];
    /** Add a document to the wallet */
    post: operations["addDocument"];
  };
  "/api/wallet/document/{id}": {
    /** Get wallet document by id */
    get: operations["getDocumentById"];
    /** Update a wallet document by id */
    put: operations["updateDocument"];
    /** Delete a wallet document by id */
    delete: operations["deleteDocument"];
  };
  "/profile.jsonld": {
    get: operations["getMasterdata"];
  };
}

export interface components {
  schemas: {
    APICreateInvitationResponse: {
      invitationUrl?: string;
      invitationId?: string;
      partnerId?: string;
    };
    AcceptInvitationRequest: {
      invitationBlock?: string;
      alias?: string;
      tag?: components["schemas"]["Tag"][];
      trustPing?: boolean;
    };
    ActivityItem: {
      id?: string;
      role?: components["schemas"]["ActivityRole"];
      state?: components["schemas"]["ActivityState"];
      type?: components["schemas"]["ActivityType"];
      /** Format: int64 */
      updatedAt?: number;
      linkId?: string;
      partner?: components["schemas"]["PartnerAPI"];
      completed?: boolean;
    };
    /** @enum {string} */
    ActivityRole:
      | "CONNECTION_REQUEST_SENDER"
      | "CONNECTION_REQUEST_RECIPIENT"
      | "CREDENTIAL_EXCHANGE_HOLDER"
      | "CREDENTIAL_EXCHANGE_ISSUER"
      | "PRESENTATION_EXCHANGE_PROVER"
      | "PRESENTATION_EXCHANGE_VERIFIER";
    /** @enum {string} */
    ActivityState:
      | "CONNECTION_REQUEST_RECEIVED"
      | "CONNECTION_REQUEST_SENT"
      | "CONNECTION_REQUEST_ACCEPTED"
      | "CREDENTIAL_EXCHANGE_SENT"
      | "CREDENTIAL_EXCHANGE_RECEIVED"
      | "CREDENTIAL_EXCHANGE_ACCEPTED"
      | "CREDENTIAL_EXCHANGE_DECLINED"
      | "CREDENTIAL_EXCHANGE_PROBLEM"
      | "PRESENTATION_EXCHANGE_SENT"
      | "PRESENTATION_EXCHANGE_RECEIVED"
      | "PRESENTATION_EXCHANGE_ACCEPTED"
      | "PRESENTATION_EXCHANGE_DECLINED";
    /** @enum {string} */
    ActivityType:
      | "CONNECTION_REQUEST"
      | "CREDENTIAL_EXCHANGE"
      | "PRESENTATION_EXCHANGE";
    AdHocMessageRequest: {
      /** Format: uuid */
      templateId?: string | null;
      /** Format: uuid */
      invitationId: string;
      /** Format: uuid */
      userInfoId?: string | null;
      /** Format: email */
      email?: string | null;
    };
    AddPartnerRequest: {
      did?: string;
      alias?: string;
      tag?: components["schemas"]["Tag"][];
      trustPing?: boolean;
    };
    AddSchemaRequest: {
      credentialType?: components["schemas"]["CredentialType"];
      label?: string | null;
      schemaId: string;
      defaultAttributeName?: string | null;
    };
    AddTagRequest: {
      name?: string;
    };
    AddTrustedIssuerRequest: {
      label?: string;
      issuerDid?: string;
    };
    ApproveProofRequest: {
      referents?: string[];
    };
    AriesCredential: {
      /** Format: uuid */
      id?: string;
      /** Format: int64 */
      issuedAt?: number;
      state?: components["schemas"]["CredentialExchangeState"];
      isPublic?: boolean;
      issuer?: string;
      schemaId?: string;
      credentialDefinitionId?: string;
      connectionId?: string;
      revoked?: boolean;
      revocable?: boolean;
      exchangeVersion?: components["schemas"]["ExchangeVersion"];
      type?: components["schemas"]["CredentialType"];
      label?: string;
      typeLabel?: string;
      credentialData?: { [key: string]: string };
    };
    AriesProofExchange: {
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      partnerId?: string;
      exchangeVersion?: components["schemas"]["ExchangeVersion"];
      state?: components["schemas"]["PresentationExchangeState"];
      role?: components["schemas"]["PresentationExchangeRole"];
      type?: components["schemas"]["CredentialType"];
      /** Format: int64 */
      updatedAt?: number;
      stateToTimestamp?: { [key: string]: number };
      typeLabel?: string;
      /** @description revealed attributes by group */
      proofData?: { [key: string]: unknown }[];
      valid?: boolean;
      proofRequest?: components["schemas"]["PresentProofRequest.ProofRequest"];
      problemReport?: string;
    };
    AttachDecorator: {
      atId: string;
      /** Format: int32 */
      byteCount: number;
      data: components["schemas"]["AttachDecoratorData"];
      description: string;
      filename: string;
      lastmodTime: string;
      mimeType: string;
    };
    AttachDecoratorData: {
      base64: string;
      json: components["schemas"]["Object"];
      jws: components["schemas"]["AttachDecoratorDataJWS"];
      links: string[];
      sha256: string;
    };
    AttachDecoratorData1JWS: {
      header: components["schemas"]["AttachDecoratorDataJWSHeader"];
      signature: string;
    };
    AttachDecoratorDataJWS: {
      header: components["schemas"]["AttachDecoratorDataJWSHeader"];
      signature: string;
      signatures: components["schemas"]["AttachDecoratorData1JWS"][];
    };
    AttachDecoratorDataJWSHeader: {
      kid: string;
    };
    Attribute: {
      name: string;
      conditions: components["schemas"]["ValueCondition"][];
    };
    AttributeGroup: {
      schemaLevelRestrictions: components["schemas"]["SchemaRestrictions"][];
      schemaId: string;
      attributeGroupName: string;
      attributes: components["schemas"]["Attribute"][];
      nonRevoked: boolean;
    };
    BPAStats: {
      /** @description my DID */
      did?: string;
      /** @description If organization profile is already there */
      profile?: boolean;
      totals?: components["schemas"]["DashboardCounts"];
      periodTotals?: components["schemas"]["DashboardCounts"];
    };
    ChatMessage: {
      /** Format: uuid */
      id?: string;
      partner?: components["schemas"]["Partner"] | null;
      content?: string;
      incoming?: boolean;
    };
    CheckInvitationRequest: {
      invitationUri?: string;
    };
    /** @enum {string} */
    ConnectionState:
      | "INIT"
      | "INVITATION"
      | "REQUEST"
      | "RESPONSE"
      | "ACTIVE"
      | "ERROR"
      | "COMPLETED"
      | "ABANDONED"
      | "START"
      | "PING_RESPONSE"
      | "PING_NO_RESPONSE";
    CreateCredDefRequest: {
      schemaId?: string;
      tag?: string;
      supportRevocation?: boolean;
    };
    CreatePartnerInvitationRequest: {
      useOutOfBand?: boolean;
      usePublicDid?: boolean;
      alias?: string;
      tag?: components["schemas"]["Tag"][];
      trustPing?: boolean;
    };
    CreateSchemaRequest: {
      schemaLabel?: string;
      defaultAttributeName?: string;
      schemaName: string;
      schemaVersion: string;
      attributes: string[];
    };
    CredDef: {
      /** Format: uuid */
      id?: string;
      schemaId?: string;
      credentialDefinitionId?: string;
      tag?: string;
      supportRevocation?: boolean;
      /** Format: int64 */
      createdAt?: number;
      schema?: components["schemas"]["SchemaAPI"];
      displayText?: string;
    };
    CredEx: {
      /** Format: uuid */
      id?: string;
      /** Format: int64 */
      createdAt?: number;
      /** Format: int64 */
      updatedAt?: number;
      partner?: components["schemas"]["PartnerAPI"];
      schemaId?: string;
      credentialDefinitionId?: string;
      proposal?: { [key: string]: string };
      credential?: components["schemas"]["Credential"];
      role?: components["schemas"]["CredentialExchangeRole"];
      state?: components["schemas"]["CredentialExchangeState"];
      stateToTimestamp?: { [key: string]: number };
      type?: components["schemas"]["CredentialType"];
      displayText?: string;
      revoked?: boolean;
      revocable?: boolean;
      exchangeVersion?: components["schemas"]["ExchangeVersion"];
      errorMsg?: string;
      schema?: components["schemas"]["SchemaAPI"];
      credDef?: components["schemas"]["CredDef"];
    };
    Credential: {
      attrs?: { [key: string]: string };
      credentialDefinitionId?: string;
      credRevId?: string;
      referent?: string;
      revRegId?: string;
      schemaId?: string;
    };
    /** @enum {string} */
    CredentialExchangeRole: "ISSUER" | "HOLDER";
    /** @enum {string} */
    CredentialExchangeState:
      | "PROPOSAL_SENT"
      | "PROPOSAL_RECEIVED"
      | "OFFER_SENT"
      | "OFFER_RECEIVED"
      | "REQUEST_SENT"
      | "REQUEST_RECEIVED"
      | "CREDENTIAL_ISSUED"
      | "CREDENTIAL_RECEIVED"
      | "CREDENTIAL_ACKED"
      | "DONE"
      | "CREDENTIAL_REVOKED"
      | "ABANDONED"
      | "DECLINED"
      | "PROBLEM";
    CredentialOfferRequest: {
      acceptProposal?: boolean;
      credDefId?: string;
      schemaId?: string;
      attributes: { [key: string]: string };
    };
    /** @enum {string} */
    CredentialType: "ORGANIZATIONAL_PROFILE_CREDENTIAL" | "INDY" | "JSON_LD";
    DIDDocument: {
      service?: components["schemas"]["DIDDocument.Service"][];
      "@context"?: string[];
      id?: string;
      alsoKnownAs?: string[];
      controller?: string;
      verificationMethod?: components["schemas"]["DIDDocument.VerificationMethod"][];
      authentication?: components["schemas"]["Object"][];
      assertionMethod?: components["schemas"]["Object"][];
      keyAgreement?: components["schemas"]["Object"][];
      capabilityInvocation?: components["schemas"]["Object"][];
      capabilityDelegation?: components["schemas"]["Object"][];
    };
    "DIDDocument.Service": {
      id?: string;
      type?: string;
      serviceEndpoint?: string;
      recipientKeys?: string[];
      routingKeys?: string[];
      /** Format: int32 */
      priority?: number;
    };
    "DIDDocument.VerificationMethod": {
      id?: string;
      type?: string;
      controller?: string;
      publicKeyBase58?: string;
    };
    DashboardCounts: {
      /** Format: int64 */
      credentialsSent?: number;
      /** Format: int64 */
      credentialsReceived?: number;
      /** Format: int64 */
      presentationRequestsSent?: number;
      /** Format: int64 */
      presentationRequestsReceived?: number;
      /** Format: int64 */
      partners?: number;
      /** Format: int64 */
      tasks?: number;
    };
    DeclineExchangeRequest: {
      message?: string;
    };
    /** @enum {string} */
    ExchangeVersion: "V1" | "V2";
    /** @enum {string} */
    "IndyProofReqPredSpec.PTypeEnum":
      | "LESS_THAN"
      | "LESS_THAN_OR_EQUAL_TO"
      | "GREATER_THAN_OR_EQUAL_TO"
      | "GREATER_THAN";
    InvitationMessage: {
      atId: string;
      atType: string;
      handshakeProtocols: string[];
      label: string;
      requestsTildeAttach: components["schemas"]["AttachDecorator"][];
      services: components["schemas"]["Object"][];
    };
    InvitationRecord: {
      createdAt: string;
      inviMsgId: string;
      invitation: components["schemas"]["InvitationMessage"];
      invitationId: string;
      invitationUrl: string;
      state: string;
      trace: boolean;
      updatedAt: string;
    };
    // @ts-ignore
    IssueCredentialRequest: (
      | components["schemas"]["IssueCredentialRequest.IssueIndyCredentialRequest"]
      | components["schemas"]["IssueCredentialRequest.IssueLDCredentialRequest"]
    ) & {
      /** Format: uuid */
      partnerId: string;
      /** @description credential exchange type */
      type?: unknown;
      /**
       * @description credential body key value pairs
       * @example {}
       */
      document?: { [key: string]: unknown }[];
    };
    // @ts-ignore
    "IssueCredentialRequest.IssueIndyCredentialRequest": components["schemas"]["IssueCredentialRequest"] & {
      /** Format: uuid */
      credDefId: string;
      /** @description credential exchange api version */
      exchangeVersion?: unknown;
    };
    // @ts-ignore
    "IssueCredentialRequest.IssueLDCredentialRequest": components["schemas"]["IssueCredentialRequest"] & {
      /** Format: uuid */
      schemaId: string;
    };
    IssueOOBCredentialRequest: {
      alias?: string;
      tag?: components["schemas"]["Tag"][];
      trustPing?: boolean;
      /** Format: uuid */
      credDefId: string;
      /**
       * @description credential body key value pairs
       * @example {}
       */
      document?: { [key: string]: unknown }[];
    };
    JsonElement: {
      jsonArray?: boolean;
      jsonObject?: boolean;
      jsonPrimitive?: boolean;
      jsonNull?: boolean;
      asJsonObject?: components["schemas"]["JsonObject"];
      asJsonArray?: { [key: string]: unknown }[];
      asJsonPrimitive?: components["schemas"]["JsonPrimitive"];
      asJsonNull?: components["schemas"]["JsonNull"];
      asBoolean?: boolean;
      asNumber?: components["schemas"]["Number"];
      asString?: string;
      /** Format: double */
      asDouble?: number;
      /** Format: float */
      asFloat?: number;
      /** Format: int64 */
      asLong?: number;
      /** Format: int32 */
      asInt?: number;
      /** Format: byte */
      asByte?: string;
      /** @deprecated */
      asCharacter?: string;
      asBigDecimal?: number;
      asBigInteger?: number;
      /** Format: int32 */
      asShort?: number;
    };
    JsonNull: components["schemas"]["JsonElement"];
    JsonObject: components["schemas"]["JsonElement"];
    JsonPrimitive: components["schemas"]["JsonElement"] & {
      boolean?: boolean;
      asBoolean?: boolean;
      number?: boolean;
      asNumber?: components["schemas"]["Number"];
      string?: boolean;
      asString?: string;
      /** Format: double */
      asDouble?: number;
      asBigDecimal?: number;
      asBigInteger?: number;
      /** Format: float */
      asFloat?: number;
      /** Format: int64 */
      asLong?: number;
      /** Format: int32 */
      asShort?: number;
      /** Format: int32 */
      asInt?: number;
      /** Format: byte */
      asByte?: string;
      asCharacter?: string;
    };
    LinkedDataProof: {
      challenge?: string;
      created?: string;
      domain?: string;
      jws?: string;
      nonce?: string;
      proofPurpose?: string;
      proofValue?: string;
      type?: components["schemas"]["ProofType"];
      verificationMethod?: string;
    };
    "MessageTemplateCmd.ApiMessageTemplate": {
      /** Format: uuid */
      id: string;
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      updatedAt: number;
      subject: string;
      template: string;
    };
    "MessageTemplateCmd.MessageTemplateRequest": {
      subject?: string;
      template: string;
    };
    /** @enum {string} */
    MessageTrigger:
      | "CONNECTION_REQUEST"
      | "CREDENTIAL_PROPOSAL"
      | "PRESENTATION_REQUEST";
    "MessageTriggerConfigCmd.ApiTriggerConfig": {
      /** Format: uuid */
      id: string;
      /** Format: int64 */
      createdAt: number;
      /** Format: int64 */
      updatedAt: number;
      trigger: components["schemas"]["MessageTrigger"];
      userInfo: components["schemas"]["MessageUserInfoCmd.ApiUserInfo"];
      template: components["schemas"]["MessageTemplateCmd.ApiMessageTemplate"];
    };
    "MessageTriggerConfigCmd.TriggerConfigRequest": {
      trigger: components["schemas"]["MessageTrigger"];
      /** Format: uuid */
      messageTemplateId?: string | null;
      /** Format: uuid */
      userInfoId: string;
    };
    /** @enum {string} */
    MessageType: "E_MAIL";
    "MessageUserInfoCmd.ApiUserInfo": {
      /** Format: uuid */
      id?: string;
      /** Format: int64 */
      createdAt?: number;
      /** Format: int64 */
      updatedAt?: number;
      type?: components["schemas"]["MessageType"];
      sendTo?: string;
      label?: string;
    };
    "MessageUserInfoCmd.UserInfoRequest": {
      /** Format: email */
      sendTo: string;
      label?: string;
    };
    MyDocumentAPI: {
      /** Format: uuid */
      id?: string;
      /** Format: int64 */
      createdAt?: number;
      /** Format: int64 */
      updatedAt?: number;
      type?: components["schemas"]["CredentialType"];
      typeLabel?: string;
      schemaId?: string;
      isPublic?: boolean;
      label?: string;
      /** @example {} */
      documentData?: { [key: string]: unknown }[];
    };
    Number: { [key: string]: unknown };
    Object: { [key: string]: unknown };
    PaginationCommand: {
      /** Format: int32 */
      size?: number;
      desc?: boolean;
      /** Format: int32 */
      page?: number;
      q?: string | null;
      types?: components["schemas"]["CredentialType"][] | null;
    };
    Partner: components["schemas"]["StateChangeDecorator_Partner.ConnectionState_"] & {
      /** Format: uuid */
      id?: string;
      /** Format: date-time */
      createdAt?: string;
      /** Format: date-time */
      updatedAt?: string;
      /**
       * Format: date-time
       * @description The last time a ping response was received from the partner
       */
      lastSeen?: string | null;
      /** @description The fully qualified did like did:sov:123 */
      did?: string;
      /**
       * @description If the partner supports aries, set if the partner has an endpoint that
       *  supports did communication
       */
      ariesSupport?: boolean;
      /** @description aries connection id */
      connectionId?: string | null;
      /** @description the current aries connection state */
      state?: components["schemas"]["ConnectionState"] | null;
      /** @description history of aries connection states - excluding ping */
      stateToTimestamp?: unknown;
      /**
       * @description aries connection label, if incoming connection set by the partner via the
       *  --label flag, or through rest overwrite
       */
      label?: string | null;
      /** @description The partners alias or name, always set by a user in the UI */
      alias?: string | null;
      /** @description Direction of the communication, incoming or outgoing aries connection */
      incoming?: boolean | null;
      /** @description If the partners public profile is valid */
      valid?: boolean | null;
      /** @description If the trust ping feature is active for this partner */
      trustPing?: boolean | null;
      /** @description Aries OOB invitation message id */
      invitationMsgId?: string | null;
      /**
       * @description The Partners Public Profile VerifiablePresentation to be used in the
       *  PartnerAPI
       */
      verifiablePresentation?:
        | components["schemas"]["VerifiablePresentation_VerifiableCredential.VerifiableIndyCredential_"]
        | null;
      /** @description credential offer or proof request when using OOB invitations with attachments */
      invitationRecord?: components["schemas"]["InvitationRecord"] | null;
      /**
       * @description Serialized PartnerCredentialType to allow filtering partners by
       *  supported credentials
       */
      supportedCredentials?: { [key: string]: unknown } | null;
      tags?: components["schemas"]["Tag"][];
    };
    PartnerAPI: {
      /**
       * @description Virtual partner name field that is calculated from the state of the Partner
       *  in the following order: 1. Alias set by a user (set when creating the
       *  connection, or editable when clicking on the pencil in the partners details)
       *  2. Legal Name from public profile if set 3. aca-py label, --label flag or
       *  overwritten when creating the connection with the label option 4. did, public
       *  or peer
       */
      name?: string;
      id?: string;
      /** Format: int64 */
      createdAt?: number;
      /** Format: int64 */
      updatedAt?: number;
      /** Format: int64 */
      lastSeen?: number;
      trustPing?: boolean;
      valid?: boolean;
      ariesSupport?: boolean;
      incoming?: boolean;
      state?: components["schemas"]["ConnectionState"];
      stateToTimestamp?: { [key: string]: number };
      alias?: string;
      label?: string;
      did?: string;
      credential?: components["schemas"]["PartnerAPI.PartnerCredential"][];
      tag?: components["schemas"]["TagAPI"][];
    };
    "PartnerAPI.PartnerCredential": {
      type?: components["schemas"]["CredentialType"];
      typeLabel?: string;
      indyCredential?: boolean;
      issuer?: string;
      schemaId?: string;
      /** @example {} */
      credentialData?: { [key: string]: unknown }[];
    };
    "PresentProofRequest.ProofRequest": {
      name?: string;
      version?: string;
      nonce?: string;
      nonRevoked?: components["schemas"]["PresentProofRequest.ProofRequest.ProofNonRevoked"];
      requestedAttributes?: {
        [
          key: string
        ]: components["schemas"]["PresentProofRequest.ProofRequest.ProofRequestedAttributes"];
      };
      requestedPredicates?: {
        [
          key: string
        ]: components["schemas"]["PresentProofRequest.ProofRequest.ProofRequestedPredicates"];
      };
    };
    "PresentProofRequest.ProofRequest.ProofNonRevoked": {
      set?: boolean;
      /** Format: int64 */
      from?: number;
      /** Format: int64 */
      to?: number;
    };
    "PresentProofRequest.ProofRequest.ProofRequestedAttributes": {
      name?: string;
      names?: string[];
      nonRevoked?: components["schemas"]["PresentProofRequest.ProofRequest.ProofNonRevoked"];
      restrictions?: components["schemas"]["JsonObject"][];
    };
    "PresentProofRequest.ProofRequest.ProofRequestedPredicates": {
      name?: string;
      nonRevoked?: components["schemas"]["PresentProofRequest.ProofRequest.ProofNonRevoked"];
      pType?: components["schemas"]["IndyProofReqPredSpec.PTypeEnum"];
      /** Format: int32 */
      pValue?: number;
      restrictions?: components["schemas"]["JsonObject"][];
    };
    /** @enum {string} */
    PresentationExchangeRole: "PROVER" | "VERIFIER";
    /** @enum {string} */
    PresentationExchangeState:
      | "PROPOSAL_SENT"
      | "PROPOSAL_RECEIVED"
      | "REQUEST_SENT"
      | "REQUEST_RECEIVED"
      | "PRESENTATIONS_SENT"
      | "PRESENTATION_RECEIVED"
      | "VERIFIED"
      | "PRESENTATION_ACKED"
      | "DONE"
      | "ABANDONED"
      | "DECLINED";
    "PresentationRequestCredentials.Interval": {
      /** Format: int32 */
      from?: number;
      /** Format: int32 */
      to?: number;
    };
    PresentationRequestCredentialsIndy: {
      credentialInfo?: components["schemas"]["PresentationRequestCredentialsIndy.CredentialInfo"];
      interval?: components["schemas"]["PresentationRequestCredentials.Interval"];
      presentationReferents?: string[];
    };
    "PresentationRequestCredentialsIndy.CredentialInfo": {
      /**
       * Format: uuid
       * @description internal credentialId BPACredentialExchange - matched via referent
       */
      credentialId?: string;
      credentialLabel?: string;
      referent?: string;
      revoked?: boolean;
      attrs?: { [key: string]: string };
      schemaId?: string;
      schemaLabel?: string;
      credentialDefinitionId?: string;
      issuerLabel?: string;
    };
    PresentationRequestCredentialsLD: {
      match?: boolean;
    };
    PresentationRequestVersion: {
      /** @description presentation exchange api version */
      exchangeVersion?: unknown;
    };
    ProofTemplate: {
      id: string | null;
      /** Format: date-time */
      createdAt: string | null;
      name: string;
      attributeGroups: components["schemas"]["AttributeGroup"][];
    };
    /** @enum {string} */
    ProofType: "Ed25519Signature2018" | "BbsBlsSignature2020";
    RequestCredentialRequest: {
      documentId?: string;
      exchangeVersion?: components["schemas"]["ExchangeVersion"];
    };
    RequestProofRequest: {
      requestBySchema?: components["schemas"]["RequestProofRequest.RequestBySchema"];
      /** Format: uuid */
      partnerId?: string;
      /**
       * @description Any valid proof request
       * @example {}
       */
      requestRaw?: { [key: string]: unknown }[];
    };
    "RequestProofRequest.RequestBySchema": {
      schemaId: string;
      issuerDid?: string[] | null;
    };
    RuntimeConfig: {
      ledger?: string;
      agentName?: string;
      uptime?: string;
      messageTrigger?: components["schemas"]["MessageTrigger"][];
      tailsServerConfigured?: boolean;
      host?: string;
      ledgerBrowser?: string;
      ledgerPrefix?: string;
      webOnly?: boolean;
      acapyEndpoint?: string;
      imprint?: string;
      dataPrivacyPolicy?: string;
      /** Format: int32 */
      revocationRegistrySize?: number;
      ux?: components["schemas"]["RuntimeConfig.UxConfig"];
      title?: string;
      locale?: string;
      fallbackLocale?: string;
      /** @description only set when running from .jar */
      buildVersion?: string;
    };
    "RuntimeConfig.UxConfig": {
      buttons?: { [key: string]: unknown };
      theme?: { [key: string]: unknown };
      favicon?: { [key: string]: unknown };
      navigation?: components["schemas"]["RuntimeConfig.UxConfig.UxConfigNavigation"];
      header?: { [key: string]: unknown };
    };
    "RuntimeConfig.UxConfig.UxConfigNavigation": {
      avatar?: components["schemas"]["RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationAvatar"];
      settings?: components["schemas"]["RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationSettings"];
      about?: components["schemas"]["RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationAbout"];
      logout?: components["schemas"]["RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationLogout"];
    };
    "RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationAbout": {
      enabled?: boolean;
    };
    "RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationAvatar": {
      agent?: components["schemas"]["RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationAvatar.UxConfigNavigationAvatarAgent"];
    };
    "RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationAvatar.UxConfigNavigationAvatarAgent": {
      default?: boolean;
      enabled?: boolean;
      src?: string;
      showName?: boolean;
    };
    "RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationLogout": {
      enabled?: boolean;
    };
    "RuntimeConfig.UxConfig.UxConfigNavigation.UxConfigNavigationSettings": {
      location?: string;
    };
    SchemaAPI: {
      /** Format: uuid */
      id?: string;
      type?: components["schemas"]["CredentialType"];
      label?: string;
      schemaId?: string;
      isMine?: boolean;
      schemaAttributeNames?: string[];
      defaultAttributeName?: string;
      trustedIssuer?: components["schemas"]["TrustedIssuer"][];
      ldType?: string;
      version?: string;
      credentialDefinitions?: components["schemas"]["CredDef"][];
    };
    SchemaRestrictions: {
      schemaId?: string | null;
      schemaName?: string | null;
      schemaVersion?: string | null;
      schemaIssuerDid?: string | null;
      credentialDefinitionId?: string | null;
      issuerDid?: string | null;
    };
    SendMessageRequest: {
      content?: string;
    };
    SendProofRequest: {
      /** Format: uuid */
      partnerId?: string;
      /** Format: uuid */
      myCredentialId?: string;
      exchangeVersion?: components["schemas"]["ExchangeVersion"];
    };
    "StateChangeDecorator.StateToTimestamp_ConnectionState_": {
      stateToTimestamp?: { [key: string]: string };
    };
    "StateChangeDecorator_Partner.ConnectionState_": {
      stateToTimestamp?: components["schemas"]["StateChangeDecorator.StateToTimestamp_ConnectionState_"];
    };
    TAADigestRequest: {
      digest?: string;
    };
    "TAAInfo.TAARecord": {
      digest?: string;
      text?: string;
      version?: string;
    };
    Tag: {
      /** Format: uuid */
      id?: string;
      name?: string;
      partners?: components["schemas"]["Partner"][];
      isReadOnly?: boolean | null;
    };
    TagAPI: {
      /** Format: uuid */
      id?: string;
      name?: string;
      isReadOnly?: boolean;
    };
    TrustedIssuer: {
      /** Format: uuid */
      id?: string;
      label?: string;
      issuerDid?: string;
    };
    UpdatePartnerDidRequest: {
      did?: string;
    };
    UpdatePartnerRequest: {
      alias?: string;
      tag?: components["schemas"]["Tag"][];
      trustPing?: boolean;
    };
    UpdateSchemaRequest: {
      /** @description Schema attribute used to create a default label */
      defaultAttribute?: string;
    };
    UpdateTagRequest: {
      name?: string;
    };
    UpdateTrustedIssuerRequest: {
      label?: string;
    };
    ValueCondition: {
      operator: components["schemas"]["ValueOperators"];
      value: string;
    };
    /** @enum {string} */
    ValueOperators:
      | "EQUALS"
      | "LESS_THAN"
      | "LESS_THAN_OR_EQUAL_TO"
      | "GREATER_THAN"
      | "GREATER_THAN_OR_EQUAL_TO";
    VerifiableCredential: {
      "@context"?: components["schemas"]["Object"][];
      credentialSubject?: components["schemas"]["JsonObject"];
      expirationDate?: string | null;
      id?: string | null;
      issuanceDate?: string | null;
      issuer?: string | null;
      proof?: components["schemas"]["LinkedDataProof"] | null;
      type?: string[];
    };
    "VerifiableCredential.LabeledVerifiableCredential": components["schemas"]["VerifiableCredential"] & {
      label?: string;
    };
    "VerifiableCredential.VerifiableIndyCredential": components["schemas"]["VerifiableCredential.LabeledVerifiableCredential"] &
      components["schemas"]["VerifiableCredential"] & {
        indyIssuer?: string | null;
        schemaId?: string | null;
        credDefId?: string | null;
      };
    "VerifiablePresentation.PresentationSubmission": {
      /** Format: uuid */
      id?: string;
      /** Format: uuid */
      definitionId?: string;
      descriptorMap?: components["schemas"]["VerifiablePresentation.PresentationSubmission.DescriptorMap"][];
    };
    "VerifiablePresentation.PresentationSubmission.DescriptorMap": {
      /** Format: int32 */
      pathAsIndex?: number;
      id?: string;
      format?: string;
      path?: string;
    };
    "VerifiablePresentation_VerifiableCredential.VerifiableIndyCredential_": {
      verifiableCredential?:
        | components["schemas"]["VerifiableCredential.VerifiableIndyCredential"][]
        | null;
      "@context": string[];
      type: string[];
      id?: string | null;
      presentationSubmission?: components["schemas"]["VerifiablePresentation.PresentationSubmission"];
      proof?: components["schemas"]["LinkedDataProof"] | null;
    };
    WalletCredentialRequest: {
      label?: string;
    };
    WalletDocumentRequest: {
      type?: components["schemas"]["CredentialType"];
      schemaId?: string;
      isPublic?: boolean;
      label?: string;
      /** @example {} */
      document?: { [key: string]: unknown }[];
    };
  };
}

export interface operations {
  getDid: {
    parameters: {};
    responses: {
      /** getDid 200 response */
      200: {
        content: {
          "application/json": components["schemas"]["DIDDocument"];
        };
      };
    };
  };
  /** List Items, if no filters return all */
  listActivities: {
    parameters: {
      query: {
        activity?: boolean | null;
        task?: boolean | null;
        type?: components["schemas"]["ActivityType"] | null;
      };
    };
    responses: {
      /** list of ActivityItem */
      200: {
        content: {
          "application/json": components["schemas"]["ActivityItem"][];
        };
      };
    };
  };
  /** Get runtime configuration */
  getRuntimeConfig: {
    parameters: {};
    responses: {
      /** RuntimeConfig */
      200: {
        content: {
          "application/json": components["schemas"]["RuntimeConfig"];
        };
      };
    };
  };
  /**
   * Trigger the backend to write configured endpoints to the ledger. TAA digest
   *  has to be passed to explicitly confirm prior TTA acceptance by the user for
   *  this ledger interaction / session.
   */
  registerEndpoints: {
    parameters: {};
    responses: {
      /** HttpResponse */
      200: unknown;
    };
    /** TAADigestRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["TAADigestRequest"];
      };
    };
  };
  isEndpointsWriteRequired: {
    parameters: {};
    responses: {
      /** true if endpoint registration is required */
      200: {
        content: {
          "application/json": boolean;
        };
      };
    };
  };
  /** List configured schemas */
  listSchemas: {
    parameters: {};
    responses: {
      /** list of SchemaAPI */
      200: {
        content: {
          "application/json": components["schemas"]["SchemaAPI"][];
        };
      };
    };
  };
  /** Import an existing indy or json-ld schema as schema configuration */
  addSchema: {
    parameters: {};
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["SchemaAPI"];
        };
      };
    };
    /** AddSchemaRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddSchemaRequest"];
      };
    };
  };
  /** Get a configured schema by id */
  getSchema: {
    parameters: {
      path: {
        /** UUID the schema id */
        id: string;
      };
    };
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["SchemaAPI"];
        };
      };
    };
  };
  /** Update a schema configuration */
  updateSchema: {
    parameters: {
      path: {
        /** UUID the schema id */
        id: string;
      };
    };
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["SchemaAPI"];
        };
      };
    };
    /** UpdateSchemaRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateSchemaRequest"];
      };
    };
  };
  /**
   * Removes a schema configuration. Doing so means the BPA will not process
   *  requests containing this schema id anymore.
   */
  removeSchema: {
    parameters: {
      path: {
        /** UUID the schema id */
        id: string;
      };
    };
    responses: {
      /** If the schema does not exist */
      404: unknown;
      /** If the schema is read only */
      405: unknown;
    };
  };
  /** Add a trusted issuer to a schema */
  addTrustedIssuer: {
    parameters: {
      path: {
        /** UUID the schema id */
        id: string;
      };
    };
    responses: {
      /** TrustedIssuer */
      200: {
        content: {
          "application/json": components["schemas"]["TrustedIssuer"];
        };
      };
    };
    /** AddTrustedIssuerRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddTrustedIssuerRequest"];
      };
    };
  };
  /** Update a trusted issuer */
  updateTrustedIssuer: {
    parameters: {
      path: {
        /** UUID the schema id */
        id: string;
        /** UUID the trusted issuer id */
        trustedIssuerId: string;
      };
    };
    responses: {
      /** TrustedIssuer */
      200: {
        content: {
          "application/json": components["schemas"]["TrustedIssuer"];
        };
      };
    };
    /** UpdateTrustedIssuerRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateTrustedIssuerRequest"];
      };
    };
  };
  /** Delete a trusted issuer */
  deleteTrustedIssuer: {
    parameters: {
      path: {
        /** UUID the schema id */
        id: string;
        /** UUID the trusted issuer id */
        trustedIssuerId: string;
      };
    };
    responses: {
      /** If the trusted issuer does not exist */
      404: unknown;
      /** If the trusted issuer is read only */
      405: unknown;
    };
  };
  /** Get TAA record (digest, text, version) */
  getTAARecord: {
    parameters: {};
    responses: {
      /** TAARecord */
      200: {
        content: {
          "application/json": components["schemas"]["TAAInfo.TAARecord"];
        };
      };
    };
  };
  /** List configured tags */
  listTags: {
    parameters: {};
    responses: {
      /** list of TagAPI */
      200: {
        content: {
          "application/json": components["schemas"]["TagAPI"][];
        };
      };
    };
  };
  /** Add a tag */
  addTag: {
    parameters: {};
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["TagAPI"];
        };
      };
    };
    /** AddTagRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddTagRequest"];
      };
    };
  };
  /** Get a configured tag */
  getTag: {
    parameters: {
      path: {
        /** UUID the tag id */
        id: string;
      };
    };
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["TagAPI"];
        };
      };
    };
  };
  /** Update a tag */
  updateTag: {
    parameters: {
      path: {
        /** UUID the tag id */
        id: string;
      };
    };
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["TagAPI"];
        };
      };
    };
    /** UpdateTagRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateTagRequest"];
      };
    };
  };
  /** Removes a tag. */
  removeTag: {
    parameters: {
      path: {
        /** UUID the tag id */
        id: string;
      };
      query: {
        force?: boolean | null;
      };
    };
    responses: {
      /** If the tag does not exist */
      404: unknown;
      /** If the tag is read only */
      405: unknown;
    };
  };
  /** Create a connection-invitation */
  requestConnectionInvitation: {
    parameters: {};
    responses: {
      /** APICreateInvitationResponse */
      200: {
        content: {
          "application/json": components["schemas"]["APICreateInvitationResponse"];
        };
      };
    };
    /** CreatePartnerInvitationRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePartnerInvitationRequest"];
      };
    };
  };
  /** Receive / accept invitation */
  acceptInvitation: {
    parameters: {};
    responses: {
      /** MutableHttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["Object"];
        };
      };
    };
    /** AcceptInvitationRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AcceptInvitationRequest"];
      };
    };
  };
  /** Check invitation (receive) */
  checkInvitation: {
    parameters: {};
    responses: {
      /** MutableHttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["Object"];
        };
      };
    };
    /** CheckInvitationRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CheckInvitationRequest"];
      };
    };
  };
  /** List credential definitions, items that I can issue */
  listCredDefs: {
    parameters: {};
    responses: {
      /** list of SchemaAPI */
      200: {
        content: {
          "application/json": components["schemas"]["CredDef"][];
        };
      };
    };
  };
  /** Create a new indy credential definition, and send it to the ledger */
  createCredDef: {
    parameters: {};
    responses: {
      /** CredDef */
      200: {
        content: {
          "application/json": components["schemas"]["CredDef"];
        };
      };
    };
    /** CreateCredDefRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateCredDefRequest"];
      };
    };
  };
  /** Delete a indy credential definition (will not delete it from the ledger) */
  deleteCredDef: {
    parameters: {
      path: {
        /** UUID the cred def id */
        id: string;
      };
    };
    responses: {
      /** HttpResponse */
      200: unknown;
    };
  };
  /** List issued or received credentials */
  listCredentialExchanges: {
    parameters: {
      query: {
        /** PaginationCommand */
        pc?: components["schemas"]["PaginationCommand"] | null;
        /** issuer or holder */
        role?: components["schemas"]["CredentialExchangeRole"] | null;
        /** partner id */
        partnerId?: string | null;
      };
    };
    responses: {
      /** list of CredEx */
      200: {
        content: {
          "application/json": components["schemas"]["CredEx"][];
        };
      };
    };
  };
  /** Get credential exchange */
  getCredentialExchange: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** list of CredEx */
      200: {
        content: {
          "application/json": components["schemas"]["CredEx"];
        };
      };
    };
  };
  /**
   * Manual credential exchange: Issuer declines credential proposal received from
   *  the holder
   */
  declineCredentialExchange: {
    parameters: {
      path: {
        /** credential exchange id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** DeclineExchangeRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeclineExchangeRequest"];
      };
    };
  };
  /**
   * Send holder a new credential offer based on an existing (revoked) exchange
   *  record
   */
  reIssueCredential: {
    parameters: {
      path: {
        /** credential exchange id */
        id: string;
      };
    };
    responses: {
      /** HttpResponse */
      200: unknown;
    };
  };
  /** Revoke an issued credential */
  revokeCredential: {
    parameters: {
      path: {
        /** credential exchange id */
        id: string;
      };
    };
    responses: {
      /** CredEx */
      200: {
        content: {
          "application/json": components["schemas"]["CredEx"];
        };
      };
    };
  };
  /**
   * Manual credential exchange step two: Issuer sends credential counter offer to
   *  holder (in reference to a proposal)
   */
  sendCredentialOffer: {
    parameters: {
      path: {
        /** credential exchange id */
        id: string;
      };
    };
    responses: {
      /** CredEx */
      200: {
        content: {
          "application/json": components["schemas"]["CredEx"];
        };
      };
    };
    /** CredentialOfferRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CredentialOfferRequest"];
      };
    };
  };
  /**
   * Issue OOB credential step 1 - prepares credential offer and returns URL for
   *  use within the barcode
   */
  issueCredentialConnectionLess: {
    parameters: {};
    responses: {
      /** APICreateInvitationResponse */
      200: {
        content: {
          "application/json": components["schemas"]["APICreateInvitationResponse"];
        };
      };
    };
    /** IssueOOBCredentialRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["IssueOOBCredentialRequest"];
      };
    };
  };
  /** Auto credential exchange: Issuer sends credential to holder */
  issueCredential: {
    parameters: {};
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": string;
        };
      };
    };
    /** IssueCredentialRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["IssueCredentialRequest"];
      };
    };
  };
  /** Create a new schema on the indy ledger and import it */
  createSchema: {
    parameters: {};
    responses: {
      /** SchemaAPI */
      200: {
        content: {
          "application/json": components["schemas"]["SchemaAPI"];
        };
      };
    };
    /** CreateSchemaRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateSchemaRequest"];
      };
    };
  };
  /** Manual trigger to send an invitation url by email */
  sendInvitationMail: {
    parameters: {};
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** AdHocMessageRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdHocMessageRequest"];
      };
    };
  };
  /** List message templates */
  listMessageTemplates: {
    parameters: {};
    responses: {
      /** list of MessageTemplateCmd.ApiMessageTemplate */
      200: {
        content: {
          "application/json": components["schemas"]["MessageTemplateCmd.ApiMessageTemplate"][];
        };
      };
    };
  };
  /** Add new message template */
  addMessageTemplate: {
    parameters: {};
    responses: {
      /** MessageTemplateCmd.ApiMessageTemplate */
      200: {
        content: {
          "application/json": components["schemas"]["MessageTemplateCmd.ApiMessageTemplate"];
        };
      };
    };
    /** MessageTemplateCmd.MessageTemplateRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MessageTemplateCmd.MessageTemplateRequest"];
      };
    };
  };
  /** Update message template */
  updateMessageTemplate: {
    parameters: {
      path: {
        /** UUID template id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** MessageTemplateCmd.MessageTemplateRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MessageTemplateCmd.MessageTemplateRequest"];
      };
    };
  };
  /** Delete message template */
  deleteMessageTemplate: {
    parameters: {
      path: {
        /** UUID template id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
  };
  /** List message trigger configuration */
  listMessageTrigger: {
    parameters: {};
    responses: {
      /** list of MessageTriggerConfigCmd.ApiTriggerConfig */
      200: {
        content: {
          "application/json": components["schemas"]["MessageTriggerConfigCmd.ApiTriggerConfig"][];
        };
      };
    };
  };
  /** ASdd new message trigger configuration */
  addMessageTrigger: {
    parameters: {};
    responses: {
      /** MessageTriggerConfigCmd.TriggerConfigRequest */
      200: {
        content: {
          "application/json": components["schemas"]["MessageTriggerConfigCmd.ApiTriggerConfig"];
        };
      };
    };
    /** MessageTriggerConfigCmd.ApiTriggerConfig */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MessageTriggerConfigCmd.TriggerConfigRequest"];
      };
    };
  };
  /** Update message trigger configuration */
  updateMessageTrigger: {
    parameters: {
      path: {
        /** UUID message trigger id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** MessageTriggerConfigCmd.TriggerConfigRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MessageTriggerConfigCmd.TriggerConfigRequest"];
      };
    };
  };
  /** Delete message trigger configuration */
  deleteMessageTrigger: {
    parameters: {
      path: {
        /** UUID message trigger id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
  };
  /** List user info */
  listUserInfo: {
    parameters: {};
    responses: {
      /** list of MessageUserInfoCmd.ApiUserInfo */
      200: {
        content: {
          "application/json": components["schemas"]["MessageUserInfoCmd.ApiUserInfo"][];
        };
      };
    };
  };
  /** Add new user info configuration */
  addUserInfo: {
    parameters: {};
    responses: {
      /** MessageUserInfoCmd.ApiUserInfo */
      200: {
        content: {
          "application/json": components["schemas"]["MessageUserInfoCmd.ApiUserInfo"];
        };
      };
    };
    /** MessageUserInfoCmd.UserInfoRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MessageUserInfoCmd.UserInfoRequest"];
      };
    };
  };
  /** Update user info configuration */
  updateUserInfo: {
    parameters: {
      path: {
        /** UUID user info id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** MessageUserInfoCmd.UserInfoRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["MessageUserInfoCmd.UserInfoRequest"];
      };
    };
  };
  /** Delete user info configuration */
  deleteUserInfo: {
    parameters: {
      path: {
        /** UUID user info id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
  };
  /** Get known partners */
  getPartners: {
    parameters: {
      query: {
        /** schema id */
        schemaId?: string | null;
      };
    };
    responses: {
      /** list of partners */
      200: {
        content: {
          "application/json": components["schemas"]["PartnerAPI"][];
        };
      };
    };
  };
  /** Add a new partner */
  addPartner: {
    parameters: {};
    responses: {
      /** PartnerAPI */
      200: {
        content: {
          "application/json": components["schemas"]["PartnerAPI"];
        };
      };
    };
    /** AddPartnerRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AddPartnerRequest"];
      };
    };
  };
  /** Lookup/Preview a partners public profile before adding */
  lookupPartner: {
    parameters: {
      path: {
        /** the partners did */
        did: string;
      };
    };
    responses: {
      /** PartnerAPI */
      200: {
        content: {
          "application/json": components["schemas"]["PartnerAPI"];
        };
      };
    };
  };
  /** Get partner by id */
  getPartnerById: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** partner */
      200: {
        content: {
          "application/json": components["schemas"]["PartnerAPI"];
        };
      };
    };
  };
  /** Update partner */
  updatePartner: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** PartnerAPI */
      200: {
        content: {
          "application/json": components["schemas"]["PartnerAPI"];
        };
      };
    };
    /** UpdatePartnerRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePartnerRequest"];
      };
    };
  };
  /** Remove partner */
  removePartner: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** HTTP status, no Body */
      200: unknown;
    };
  };
  /** Manual connection flow. Accept partner connection request */
  acceptPartnerRequest: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** HTTP status, no Body */
      200: unknown;
    };
  };
  /** Request credential from partner */
  requestCredential: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** RequestCredentialRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["RequestCredentialRequest"];
      };
    };
  };
  /** Update partner's did */
  updatePartnerDid: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** PartnerAPI */
      200: {
        content: {
          "application/json": components["schemas"]["PartnerAPI"];
        };
      };
    };
    /** UpdatePartnerRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePartnerDidRequest"];
      };
    };
  };
  /** Get chat messages for partner */
  getMessagesForPartner: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: {
        content: {
          "application/json": components["schemas"]["ChatMessage"][];
        };
      };
    };
  };
  /** Send chat message to partner */
  sendMessage: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** SendMessageRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendMessageRequest"];
      };
    };
  };
  /** List proof exchange records */
  getPartnerProofs: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: {
        content: {
          "application/json": components["schemas"]["AriesProofExchange"][];
        };
      };
    };
  };
  /**
   * Request proof from partner
   *
   *               ProofExchangeController#requestProof
   */
  requestProof: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** One of requestBySchema or requestRaw */
    requestBody: {
      content: {
        "application/json": components["schemas"]["RequestProofRequest"];
      };
    };
  };
  /** Request proof from partner by proof template */
  invokeProofRequestByTemplate: {
    parameters: {
      path: {
        /** partner id */
        id: string;
        /** proof template id */
        templateId: string;
      };
    };
    responses: {
      /** Http Status */
      200: unknown;
    };
    /** PresentationRequestVersion */
    requestBody: {
      content: {
        "application/json": components["schemas"]["PresentationRequestVersion"];
      };
    };
  };
  /**
   * Send proof to partner
   *
   *               ProofExchangeController#sendProof
   */
  sendProof: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** SendProofRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendProofRequest"];
      };
    };
  };
  /** Reload/Re- lookup a partners public profile */
  refreshPartner: {
    parameters: {
      path: {
        /** UUID the partner id */
        id: string;
      };
    };
    responses: {
      /** PartnerAPI */
      200: {
        content: {
          "application/json": components["schemas"]["PartnerAPI"];
        };
      };
    };
  };
  /** Request proof from partner */
  requestProof_1: {
    parameters: {};
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** One of requestBySchema or requestRaw */
    requestBody: {
      content: {
        "application/json": components["schemas"]["RequestProofRequest"];
      };
    };
  };
  /** Send proof to partner */
  sendProof_1: {
    parameters: {};
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** SendProofRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["SendProofRequest"];
      };
    };
  };
  /** Get proof exchange by id */
  getProofExchangeById: {
    parameters: {
      path: {
        /** UUID presentation exchange id */
        id: string;
      };
    };
    responses: {
      /** AriesProofExchange */
      200: {
        content: {
          "application/json": components["schemas"]["AriesProofExchange"];
        };
      };
    };
  };
  /** Aries: Deletes a proof exchange by id */
  deleteProofExchangeById: {
    parameters: {
      path: {
        /** the proof exchange id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
  };
  /** Manual proof exchange flow. Reject ProofRequest received from a partner */
  declinePresentProofRequest: {
    parameters: {
      path: {
        /** UUID the presentationExchangeId */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** DeclineExchangeRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeclineExchangeRequest"];
      };
    };
  };
  /**
   * Manual proof exchange flow. Get matching wallet credentials before sending or
   *  declining the proof request.
   */
  getMatchingCredentials: {
    parameters: {
      path: {
        /** UUID the presentationExchangeId */
        id: string;
      };
    };
    responses: {
      /** list of PresentationRequestCredentialsIndy */
      200: {
        content: {
          "application/json": components["schemas"]["PresentationRequestCredentialsIndy"][];
        };
      };
    };
  };
  getMatchingLDCredentials: {
    parameters: {
      path: {
        id: string;
      };
    };
    responses: {
      /** getMatchingLDCredentials 200 response */
      200: {
        content: {
          "application/json": components["schemas"]["PresentationRequestCredentialsLD"];
        };
      };
    };
  };
  /** Manual proof exchange flow. Answer ProofRequest with matching attributes */
  responseToProofRequest: {
    parameters: {
      path: {
        /** UUID the presentationExchangeId */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** ApproveProofRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ApproveProofRequest"];
      };
    };
  };
  /** List configured templates */
  listProofTemplates: {
    parameters: {};
    responses: {
      /** list of ProofTemplate */
      200: {
        content: {
          "application/json": components["schemas"]["ProofTemplate"][];
        };
      };
    };
  };
  /** Add a new proof template */
  addProofTemplate: {
    parameters: {};
    responses: {
      /** ProofTemplate */
      200: {
        content: {
          "application/json": components["schemas"]["ProofTemplate"];
        };
      };
    };
    /** ProofTemplate */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ProofTemplate"];
      };
    };
  };
  /** List configured proof condition operators */
  listKnownConditionOperators: {
    parameters: {};
    responses: {
      /** list of ValueOperators */
      200: {
        content: {
          "application/json": string[];
        };
      };
    };
  };
  /** Get template by id */
  getProofTemplateForId: {
    parameters: {
      path: {
        /** proof template id */
        id: string;
      };
    };
    responses: {
      /** ProofTemplate */
      200: {
        content: {
          "application/json": components["schemas"]["ProofTemplate"];
        };
      };
    };
  };
  /** Delete proof template by id */
  removeProofTemplate: {
    parameters: {
      path: {
        /** proof template id */
        id: string;
      };
    };
    responses: {
      /** Http Status */
      200: unknown;
    };
  };
  /** Get simple BPA information and usage statistics */
  getStats: {
    parameters: {};
    responses: {
      /** BPAStats */
      200: {
        content: {
          "application/json": components["schemas"]["BPAStats"];
        };
      };
    };
  };
  /** Aries: List wallet credentials */
  getCredentials: {
    parameters: {
      query: {
        /** PaginationCommand */
        pc?: components["schemas"]["PaginationCommand"] | null;
      };
    };
    responses: {
      /** list of AriesCredential */
      200: {
        content: {
          "application/json": components["schemas"]["AriesCredential"][];
        };
      };
    };
  };
  /** Aries: Get wallet credential by id */
  getCredentialById: {
    parameters: {
      path: {
        /** the credential id */
        id: string;
      };
    };
    responses: {
      /** AriesCredential */
      200: {
        content: {
          "application/json": components["schemas"]["AriesCredential"];
        };
      };
    };
  };
  /** Aries: Set/update a credentials label */
  updateCredential: {
    parameters: {
      path: {
        /** the credential id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** WalletCredentialRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["WalletCredentialRequest"];
      };
    };
  };
  /** Aries: Delete a wallet credential by id */
  deleteCredential: {
    parameters: {
      path: {
        /** the credential id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
  };
  /**
   * Manual credential exchange step four: Holder accepts credential offer from
   *  issuer
   */
  acceptCredentialOffer: {
    parameters: {
      path: {
        /** the credential id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
  };
  /** Manual credential exchange: Holder declines credential offer from issuer */
  declineCredentialOffer: {
    parameters: {
      path: {
        /** the credential id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
    /** DeclineExchangeRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["DeclineExchangeRequest"];
      };
    };
  };
  /** Toggles the credential's visibility in the public profile */
  toggleCredentialVisibility: {
    parameters: {
      path: {
        /** the credential id */
        id: string;
      };
    };
    responses: {
      /** HttpResponse */
      200: unknown;
    };
  };
  /** List wallet documents */
  getDocuments: {
    parameters: {
      query: {
        /** PaginationCommand multi value list of types to filter */
        pc?: components["schemas"]["PaginationCommand"] | null;
      };
    };
    responses: {
      /** list of MyDocumentAPI */
      200: {
        content: {
          "application/json": components["schemas"]["Object"][];
        };
      };
    };
  };
  /** Add a document to the wallet */
  addDocument: {
    parameters: {};
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["MyDocumentAPI"];
        };
      };
    };
    /** WalletDocumentRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["WalletDocumentRequest"];
      };
    };
  };
  /** Get wallet document by id */
  getDocumentById: {
    parameters: {
      path: {
        /** the document id */
        id: string;
      };
    };
    responses: {
      /** MyDocumentAPI */
      200: {
        content: {
          "application/json": components["schemas"]["MyDocumentAPI"];
        };
      };
    };
  };
  /** Update a wallet document by id */
  updateDocument: {
    parameters: {
      path: {
        /** the document id */
        id: string;
      };
    };
    responses: {
      /** HttpResponse */
      200: {
        content: {
          "application/json": components["schemas"]["MyDocumentAPI"];
        };
      };
    };
    /** WalletDocumentRequest */
    requestBody: {
      content: {
        "application/json": components["schemas"]["WalletDocumentRequest"];
      };
    };
  };
  /** Delete a wallet document by id */
  deleteDocument: {
    parameters: {
      path: {
        /** the document id */
        id: string;
      };
    };
    responses: {
      /** HTTP status */
      200: unknown;
    };
  };
  getMasterdata: {
    parameters: {};
    responses: {
      /** getMasterdata 200 response */
      200: {
        content: {
          "application/json": components["schemas"]["VerifiablePresentation_VerifiableCredential.VerifiableIndyCredential_"];
        };
      };
    };
  };
}

export interface external {}
